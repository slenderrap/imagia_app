Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\r\n    alias(libs.plugins.android.application)\r\n    alias(libs.plugins.kotlin.android)\r\n}\r\n\r\nandroid {\r\n    namespace = \"com.project.imagia\"\r\n    compileSdk = 35\r\n\r\n    defaultConfig {\r\n        applicationId = \"com.project.imagia\"\r\n        minSdk = 34\r\n        targetSdk = 34\r\n        versionCode = 1\r\n        versionName = \"1.0\"\r\n\r\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            isMinifyEnabled = false\r\n            proguardFiles(\r\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\r\n                \"proguard-rules.pro\"\r\n            )\r\n        }\r\n    }\r\n    compileOptions {\r\n        sourceCompatibility = JavaVersion.VERSION_1_8\r\n        targetCompatibility = JavaVersion.VERSION_1_8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n    buildFeatures {\r\n        viewBinding = true\r\n    }\r\n    buildToolsVersion = \"34.0.0\"\r\n    dependenciesInfo {\r\n        includeInApk = true\r\n        includeInBundle = true\r\n    }\r\n\r\n\r\n}\r\n\r\ndependencies {\r\n    implementation(libs.androidx.core.ktx)\r\n    implementation(libs.androidx.appcompat)\r\n    implementation(libs.material)\r\n    implementation(libs.androidx.constraintlayout)\r\n    implementation(libs.androidx.lifecycle.livedata.ktx)\r\n    implementation(libs.androidx.lifecycle.viewmodel.ktx)\r\n    implementation(libs.androidx.navigation.fragment.ktx)\r\n    implementation(libs.androidx.navigation.ui.ktx)\r\n    implementation(libs.androidx.camera.lifecycle)\r\n    implementation(libs.androidx.camera.core)\r\n    implementation(libs.androidx.camera.camera2) // Asegúrate de que esta esté incluida\r\n    implementation(libs.androidx.camera.view)\r\n    testImplementation(libs.junit)\r\n    androidTestImplementation(libs.androidx.junit)\r\n    androidTestImplementation(libs.androidx.espresso.core)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
--- a/app/build.gradle.kts	
+++ b/app/build.gradle.kts	
@@ -56,9 +56,11 @@
     implementation(libs.androidx.navigation.ui.ktx)
     implementation(libs.androidx.camera.lifecycle)
     implementation(libs.androidx.camera.core)
-    implementation(libs.androidx.camera.camera2) // Asegúrate de que esta esté incluida
+    implementation(libs.androidx.camera.camera2)
     implementation(libs.androidx.camera.view)
+    implementation(libs.okhttp)
     testImplementation(libs.junit)
     androidTestImplementation(libs.androidx.junit)
     androidTestImplementation(libs.androidx.espresso.core)
+
 }
\ No newline at end of file
Index: gradle/libs.versions.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[versions]\r\nagp = \"8.6.0\"\r\nkotlin = \"1.9.0\"\r\ncoreKtx = \"1.15.0\"\r\njunit = \"4.13.2\"\r\njunitVersion = \"1.2.1\"\r\nespressoCore = \"3.6.1\"\r\nappcompat = \"1.7.0\"\r\nmaterial = \"1.12.0\"\r\nconstraintlayout = \"2.2.0\"\r\nlifecycleLivedataKtx = \"2.8.7\"\r\nlifecycleViewmodelKtx = \"2.8.7\"\r\nnavigationFragmentKtx = \"2.8.5\"\r\nnavigationUiKtx = \"2.8.5\"\r\ncameraLifecycle = \"1.4.1\"\r\ncameraCore = \"1.4.1\"\r\n\r\n[libraries]\r\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\r\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\r\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\r\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\r\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\r\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\r\nandroidx-constraintlayout = { group = \"androidx.constraintlayout\", name = \"constraintlayout\", version.ref = \"constraintlayout\" }\r\nandroidx-lifecycle-livedata-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-livedata-ktx\", version.ref = \"lifecycleLivedataKtx\" }\r\nandroidx-lifecycle-viewmodel-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-viewmodel-ktx\", version.ref = \"lifecycleViewmodelKtx\" }\r\nandroidx-navigation-fragment-ktx = { group = \"androidx.navigation\", name = \"navigation-fragment-ktx\", version.ref = \"navigationFragmentKtx\" }\r\nandroidx-navigation-ui-ktx = { group = \"androidx.navigation\", name = \"navigation-ui-ktx\", version.ref = \"navigationUiKtx\" }\r\nandroidx-camera-lifecycle = { group = \"androidx.camera\", name = \"camera-lifecycle\", version.ref = \"cameraLifecycle\" }\r\nandroidx-camera-core = { group = \"androidx.camera\", name = \"camera-core\", version.ref = \"cameraCore\" }\r\nandroidx-camera-camera2 = {group = \"androidx.camera\",name=\"camera-camera2\",version.ref =\"cameraLifecycle\"}\r\nandroidx-camera-view = {module = \"androidx.camera:camera-view\", version.ref =\"cameraLifecycle\"}\r\n\r\n[plugins]\r\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\r\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
--- a/gradle/libs.versions.toml	
+++ b/gradle/libs.versions.toml	
@@ -16,6 +16,7 @@
 cameraCore = "1.4.1"
 
 [libraries]
+okhttp = { module = "com.squareup.okhttp3:okhttp", version = "4.9.3" }
 androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
 junit = { group = "junit", name = "junit", version.ref = "junit" }
 androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
Index: app/src/main/java/com/project/imagia/ui/ullada/UlladaFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.project.imagia.ui.ullada\r\n\r\nimport android.Manifest\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.os.Bundle\r\nimport android.provider.MediaStore\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.TextView\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.lifecycle.ViewModelProvider\r\nimport com.project.imagia.databinding.FragmentUlladaBinding\r\nimport android.annotation.SuppressLint\r\nimport android.content.ContentValues\r\nimport android.content.pm.PackageManager\r\nimport android.hardware.Sensor\r\nimport android.hardware.SensorEvent\r\nimport android.hardware.SensorEventListener\r\nimport android.hardware.SensorManager\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport androidx.activity.enableEdgeToEdge\r\nimport androidx.activity.result.contract.ActivityResultContracts\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.camera.core.CameraSelector\r\nimport androidx.camera.core.ImageAnalysis\r\nimport androidx.camera.core.ImageCapture\r\nimport androidx.camera.core.ImageCaptureException\r\nimport androidx.camera.core.ImageProxy\r\nimport androidx.camera.core.Preview\r\nimport androidx.camera.lifecycle.ProcessCameraProvider\r\nimport androidx.core.content.ContextCompat\r\nimport androidx.core.view.ViewCompat\r\nimport androidx.core.view.WindowInsetsCompat\r\nimport java.nio.ByteBuffer\r\nimport java.text.SimpleDateFormat\r\nimport java.util.Locale\r\nimport java.util.concurrent.ExecutorService\r\nimport java.util.concurrent.Executors\r\nimport kotlin.math.abs\r\n\r\n\r\ntypealias LumaListener = (luma: Double) -> Unit\r\n\r\nclass UlladaFragment : Fragment() ,SensorEventListener{\r\n\r\n    private lateinit var sensorManager: SensorManager\r\n    private lateinit var accelerometer: Sensor\r\n    private lateinit var linearAccelerometer: Sensor\r\n    private var _binding: FragmentUlladaBinding? = null\r\n    private var imageCapture: ImageCapture? = null\r\n    private lateinit var cameraExecutor: ExecutorService\r\n\r\n\r\n    // This property is only valid between onCreateView and\r\n    // onDestroyView.\r\n    private val binding get() = _binding!!\r\n\r\n    private var tapCounterX = 0\r\n    private var tapCounterY = 0\r\n    private var tapCounterZ = 0\r\n    private val threshold = 6.0\r\n    private val timeWindow = 300L\r\n    private var lastTapTime = 0L\r\n\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n\r\n        sensorManager = requireContext().getSystemService(Context.SENSOR_SERVICE) as SensorManager\r\n\r\n        if (allPermissionsGranted()) {\r\n            startCamera()\r\n        } else {\r\n            requestPermissions()\r\n        }\r\n\r\n\r\n        val ulladaViewModel =\r\n            ViewModelProvider(this).get(UlladaViewModel::class.java)\r\n\r\n        _binding = FragmentUlladaBinding.inflate(inflater, container, false)\r\n        val root: View = binding.root\r\n        // Set up the listeners for take photo and video capture buttons\r\n        _binding!!.button.setOnClickListener { takePhoto() }\r\n\r\n        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)!!\r\n        linearAccelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION)!!\r\n\r\n        sensorManager.registerListener(this,linearAccelerometer,SensorManager.SENSOR_DELAY_NORMAL)\r\n        sensorManager.registerListener(this,linearAccelerometer,SensorManager.SENSOR_DELAY_NORMAL)\r\n        cameraExecutor = Executors.newSingleThreadExecutor()\r\n\r\n        val textView: TextView = binding.textHome\r\n        ulladaViewModel.text.observe(viewLifecycleOwner) {\r\n            textView.text = it\r\n        }\r\n        return binding.root\r\n    }\r\n    private fun takePhoto() {\r\n\r\n        // Get a stable reference of the modifiable image capture use case\r\n        val imageCapture = imageCapture ?: return\r\n\r\n        // Create time stamped name and MediaStore entry.\r\n        val name = SimpleDateFormat(FILENAME_FORMAT, Locale.US)\r\n            .format(System.currentTimeMillis())\r\n        val contentValues = ContentValues().apply {\r\n            put(MediaStore.MediaColumns.DISPLAY_NAME, name)\r\n            put(MediaStore.MediaColumns.MIME_TYPE, \"image/jpeg\")\r\n            put(MediaStore.Images.Media.RELATIVE_PATH, \"Pictures/CameraX-Image\")\r\n        }\r\n\r\n\r\n        // Create output options object which contains file + metadata\r\n        val outputOptions = ImageCapture.OutputFileOptions\r\n            .Builder(requireContext().contentResolver,\r\n                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\r\n                contentValues)\r\n            .build()\r\n\r\n\r\n        // been taken\r\n        imageCapture.takePicture(\r\n            outputOptions,\r\n            ContextCompat.getMainExecutor(this.requireContext()),\r\n            object : ImageCapture.OnImageSavedCallback {\r\n                override fun onError(exc: ImageCaptureException) {\r\n                    Log.e(TAG, \"Photo capture failed: ${exc.message}\", exc)\r\n                }\r\n\r\n                override fun\r\n                        onImageSaved(output: ImageCapture.OutputFileResults){\r\n                    val msg = \"Photo capture succeeded: ${output.savedUri}\"\r\n                    Toast.makeText(requireContext(), msg, Toast.LENGTH_SHORT).show()\r\n                    Log.d(TAG, msg)\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n\r\n    override fun onDestroyView() {\r\n        super.onDestroyView()\r\n        cameraExecutor.shutdown()\r\n        sensorManager.unregisterListener(this)\r\n        _binding = null\r\n    }\r\n    override fun onSensorChanged(event: SensorEvent){\r\n\r\n        val x = event.values[0]\r\n        val y = event.values[1]\r\n        val z = event.values[2]\r\n        detectDoubleTap(x, y, z)\r\n\r\n\r\n\r\n    }\r\n\r\n    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {\r\n        // no hace falta implementarlo porque no cambia la precision de los sensores\r\n    }\r\n\r\n    private fun detectDoubleTap(x: Float, y: Float, z: Float) {\r\n        val currentTime = System.currentTimeMillis()\r\n        if (abs(x) > threshold || abs(y) > threshold || abs(z) > threshold) {\r\n            if (currentTime - lastTapTime < timeWindow) {\r\n                Toast.makeText(requireContext(),\"S'ha detectat un segon tap\",Toast.LENGTH_SHORT).show()\r\n                takePhoto()\r\n            } else {\r\n                Toast.makeText(requireContext(),\"S'ha detectat un tap\",Toast.LENGTH_SHORT).show()\r\n            }\r\n            lastTapTime = currentTime\r\n        }\r\n    }\r\n    override fun onSaveInstanceState(outState: Bundle) {\r\n        super.onSaveInstanceState(outState)\r\n        outState.putInt(\"tapCounterX\", tapCounterX)\r\n        outState.putInt(\"tapCounterY\", tapCounterY)\r\n        outState.putInt(\"tapCounterZ\", tapCounterZ)\r\n    }\r\n\r\n\r\n    private fun requestPermissions() {\r\n        activityResultLauncher.launch(REQUIRED_PERMISSIONS)\r\n    }\r\n\r\n    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {\r\n        ContextCompat.checkSelfPermission(\r\n            requireContext(), it) == PackageManager.PERMISSION_GRANTED\r\n    }\r\n    companion object {\r\n        private const val TAG = \"CameraXApp\"\r\n        private const val FILENAME_FORMAT = \"yyyy-MM-dd-HH-mm-ss-SSS\"\r\n        private val REQUIRED_PERMISSIONS =\r\n            mutableListOf (\r\n                Manifest.permission.CAMERA,\r\n            ).apply {\r\n            }.toTypedArray()\r\n    }\r\n    private val activityResultLauncher =\r\n        registerForActivityResult(\r\n            ActivityResultContracts.RequestMultiplePermissions())\r\n        { permissions ->\r\n            // Handle Permission granted/rejected\r\n            var permissionGranted = true\r\n            permissions.entries.forEach {\r\n                if (it.key in REQUIRED_PERMISSIONS && it.value == false)\r\n                    permissionGranted = false\r\n            }\r\n            if (!permissionGranted) {\r\n                Toast.makeText(requireContext(),\r\n                    \"Permission request denied\",\r\n                    Toast.LENGTH_SHORT).show()\r\n            } else {\r\n                startCamera()\r\n            }\r\n        }\r\n\r\n    private fun startCamera() {\r\n        val cameraProviderFuture = ProcessCameraProvider.getInstance(requireContext())\r\n\r\n        cameraProviderFuture.addListener({\r\n            // Obtén el proveedor de cámara\r\n            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()\r\n\r\n            // Selecciona la cámara trasera como predeterminada\r\n            val cameraSelector = CameraSelector.Builder()\r\n                .requireLensFacing(CameraSelector.LENS_FACING_BACK)\r\n                .build()\r\n\r\n            try {\r\n                // Unbind all use cases antes de volver a adjuntar\r\n                cameraProvider.unbindAll()\r\n\r\n\r\n                imageCapture = ImageCapture.Builder()\r\n                    .setTargetRotation(requireActivity().windowManager.defaultDisplay.rotation)\r\n                    .build()\r\n                // Vincula el caso de vista previa\r\n                val preview = Preview.Builder().build().also {\r\n                    it.setSurfaceProvider(binding.previewFinder.surfaceProvider)\r\n                }\r\n                cameraProvider.bindToLifecycle(this, cameraSelector, preview,imageCapture)\r\n\r\n            } catch (exc: Exception) {\r\n                Log.e(TAG, \"Error al vincular la cámara\", exc)\r\n            }\r\n        }, ContextCompat.getMainExecutor(requireContext()))\r\n    }\r\n    private class LuminosityAnalyzer(private val listener: LumaListener) : ImageAnalysis.Analyzer {\r\n\r\n        private fun ByteBuffer.toByteArray(): ByteArray {\r\n            rewind()    // Rewind the buffer to zero\r\n            val data = ByteArray(remaining())\r\n            get(data)   // Copy the buffer into a byte array\r\n            return data // Return the byte array\r\n        }\r\n\r\n        override fun analyze(image: ImageProxy) {\r\n\r\n            val buffer = image.planes[0].buffer\r\n            val data = buffer.toByteArray()\r\n            val pixels = data.map { it.toInt() and 0xFF }\r\n            val luma = pixels.average()\r\n\r\n            listener(luma)\r\n\r\n            image.close()\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/project/imagia/ui/ullada/UlladaFragment.kt b/app/src/main/java/com/project/imagia/ui/ullada/UlladaFragment.kt
--- a/app/src/main/java/com/project/imagia/ui/ullada/UlladaFragment.kt	
+++ b/app/src/main/java/com/project/imagia/ui/ullada/UlladaFragment.kt	
@@ -35,6 +35,14 @@
 import androidx.core.content.ContextCompat
 import androidx.core.view.ViewCompat
 import androidx.core.view.WindowInsetsCompat
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.MultipartBody
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody
+import java.io.File
 import java.nio.ByteBuffer
 import java.text.SimpleDateFormat
 import java.util.Locale
@@ -179,6 +187,9 @@
             lastTapTime = currentTime
         }
     }
+
+
+
     override fun onSaveInstanceState(outState: Bundle) {
         super.onSaveInstanceState(outState)
         outState.putInt("tapCounterX", tapCounterX)
@@ -277,6 +288,39 @@
     }
 
 
+    suspend fun postToServer(url: String, imageFile: File): String {
+        return withContext(Dispatchers.IO) {
+            try {
+                val client = OkHttpClient()
+
+                // Crear el cuerpo de la imagen
+                val requestBody = MultipartBody.Builder()
+                    .setType(MultipartBody.FORM)
+                    .addFormDataPart(
+                        "image", imageFile.name,
+                        RequestBody.create("image/jpeg".toMediaType(), imageFile)
+                    )
+                    .build()
+
+                // Crear la solicitud HTTP
+                val request = Request.Builder()
+                    .url(url)
+                    .post(requestBody)
+                    .build()
+
+                // Ejecutar la solicitud
+                client.newCall(request).execute().use { response ->
+                    if (!response.isSuccessful) {
+                        throw Exception("Error: ${response.code} ${response.message}")
+                    }
+                    response.body?.string() ?: throw Exception("Respuesta vacía del servidor")
+                }
+            } catch (e: Exception) {
+                throw Exception("Error al enviar la imagen al servidor: ${e.message}", e)
+            }
+        }
+    }
+
 
 
 }
\ No newline at end of file
